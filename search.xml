<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>article0006</title>
      <link href="/2019/03/27/article0006/"/>
      <url>/2019/03/27/article0006/</url>
      
        <content type="html"><![CDATA[<h1 id="交大oj水题17道题解—-2019-03-27"><a href="#交大oj水题17道题解—-2019-03-27" class="headerlink" title="交大oj水题17道题解—-2019.03.27"></a>交大oj水题17道题解—-2019.03.27</h1><p>—-数据结构(俞勇班)第三次作业</p><h2 id="1005-数独"><a href="#1005-数独" class="headerlink" title="1005.数独"></a>1005.数独</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1005" target="_blank" rel="noopener">1005</a></p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>检验数独的合法性，保证输入为1~9的整数</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>暴力</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre style="color:White; bgcolor:Black">#include &lt;cstdio&gt;#include &lt;cstring&gt; int A[10][10];int cnt[12];int X[9] = {0, 0, 0, 3, 3, 3, 6, 6, 6}, Y[9] = {0, 3, 6, 0, 3, 6, 0, 3, 6};int dx[9] = {0, 0, 0, 1, 1, 1, 2, 2, 2}, dy[9] = {0, 1, 2, 0, 1, 2, 0, 1, 2};bool judge1(int p){    memset(cnt, 0, sizeof(cnt));    for(int i = 0; i &lt; 9; ++i) ++cnt[A[p][i]];    for(int i = 1; i &lt;= 9; ++i)        if(cnt[i] != 1)            return 1;    return 0;}bool judge2(int p){    memset(cnt, 0, sizeof(cnt));    for(int i = 0; i &lt; 9; ++i) ++cnt[A[i][p]];    for(int i = 1; i &lt;= 9; ++i)        if(cnt[i] != 1)            return 1;    return 0;}bool judge3(int p){    memset(cnt, 0, sizeof(cnt));    int xx = X[p], yy = Y[p];    for(int i = 0; i &lt; 9; ++i) ++cnt[A[xx + dx[i]][yy+ dy[i]]];    for(int i = 1; i &lt;= 9; ++i)        if(cnt[i] != 1)            return 1;    return 0;}void work(){    for(int i = 0; i &lt; 9; ++i)        for(int j = 0; j &lt; 9; ++j)            scanf("%d", &#38;A[i][j]);    for(int i = 0; i &lt; 9; ++i)        if(judge1(i) || judge2(i) || judge3(i))        {            printf("Wrong\n");            return ;        }    printf("Right\n");    return ;}    int main(){    int n;    scanf("%d", &#38;n);    for(int i = 1; i &lt;= n; ++i)        work();    return 0;}</pre><h2 id="4009-步步为赢"><a href="#4009-步步为赢" class="headerlink" title="4009.步步为赢"></a>4009.步步为赢</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/4009" target="_blank" rel="noopener">4009</a></p><h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>明文，密文转换，模拟</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>模拟</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre style="color:White; bgcolor:Black">#include &lt;cstdio&gt;#include &lt;cstring&gt;char str1[200], str2[200];int len;bool check(int p){    int cnt = 0;    for(int i = 0; i &lt; p; ++i)        for(int j = i; j &lt; len; j += p)            if(str1[j] != str2[cnt++])                return 0;    return 1;}int main(){    scanf("%s%s", str1, str2);    len = strlen(str1);    if(strlen(str2) != len)    {        printf("No Solution\n");        return 0;    }    for(int i = 1; i &lt;= len; ++i)        if(len % i == 0 && check(i))        {            printf("%d\n", i);            return 0;        }    printf("No Solution\n");    return 0;}</pre><h2 id="3016-均分纸牌"><a href="#3016-均分纸牌" class="headerlink" title="3016.均分纸牌"></a>3016.均分纸牌</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/3016" target="_blank" rel="noopener">3016</a></p><h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>有n堆纸牌，每一堆都有若干张，且保证总张数为n的整数倍。<br>将一堆纸牌的部分(或全部)纸牌，转移到相邻的纸牌堆，称之为一次操作。<br>求解使得每堆纸牌同样多的最少操作数。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p>直接模拟。很容易发现，对于每一对相邻的纸牌堆，至多需要进行一次操作。<br>从左往右模拟。多了就分给右边，不足就从右边拿(把右边拿成负数也不妨，反正总数是足够的)。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;int A[120], n, summ = 0, cnt = 0;int main(){    scanf("%d", &n);    for(int i = 1; i &lt;= n; ++i)    {        scanf("%d", &A[i]);        summ += A[i];    }    summ /= n;    for(int i = 1; i &lt; n; ++i)        if(A[i] != summ)        {            A[i + 1] += A[i] - summ;            A[i] = summ;            ++cnt;        }    printf("%d\n", cnt);    return 0;}</pre><h2 id="4045-日天要读书"><a href="#4045-日天要读书" class="headerlink" title="4045.日天要读书"></a>4045.日天要读书</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/4045" target="_blank" rel="noopener">4045</a></p><h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个1~n的排列，以及m个形如(L,R,X)的询问:<br>对于每一个询问,在<strong>原</strong>排列基础上将位置在[L,R]的序列升序排序，排序前后，<br>若X位置上的数未发生变化，输出Yes,<br>若X位置上的数发生了变化，输出No.<br>参见原题目的样例解释</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>此题应该有简单解法，毕竟是放在入门作业题中的<br>由于数据范围是$1 \leq n , m\leq 10^4$ 加上实际数据并没有给满(询问的区间长度没给满)，<br>所以裸跑暴力也勉强能过, 时间复杂度 O(mnlog n)</p><p>相当于求静态区间第k小</p><ol><li>莫队+树状数组 $O(m\cdot\sqrt{n}\log{n})$</li><li>整体二分+树状数组 $O(m\cdot\log^2{n})$</li><li>主席树 </li></ol><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><h4 id="莫队-树状数组"><a href="#莫队-树状数组" class="headerlink" title="莫队+树状数组"></a>莫队+树状数组</h4><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 10500#define lowbit(x) ((x)&-(x))int tr[MAXN], n;void _r(int& x){    char c = getchar();    while(c &lt; '0' || c &gt; '9')        c = getchar();    for(x = 0; c &gt;= '0' && c &lt;= '9'; c = getchar())        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0';    return ;}void modify(int x, int delta){    for(int i = x; i &lt;= n + 10; i += lowbit(i))        tr[i] += delta;}int query(int x){    int ans = 0;    for(int i = x; i; i -= lowbit(i))        ans += tr[i];    return ans;}const int I = 100;struct interval{    int L, R, que, id, L2;    interval(){}    interval(int _L, int _R, int _que, int _id)    {        L = _L;        R = _R;        que = _que;        id = _id;        L2 = L / I;    }}Q[MAXN];bool cmp(interval a, interval b){    if(a.L2 == b.L2) return a.R &lt; b.R;    return a.L2 &lt; b.L2;}int A[MAXN], m, ans[MAXN];int main(){    _r(n);    _r(m);    for(int i = 1; i &lt;= n; ++i)         _r(A[i]);    for(int i = 1, l, r, x; i &lt;= m; ++i)    {        _r(l); _r(r); _r(x);        Q[i] = interval(l, r, x, i);    }    sort(Q + 1, Q + m + 1, cmp);    int X = 1, Y = 0;    for(int i = 1, L, R; i &lt;= m; ++i)    {        L = Q[i].L;        R = Q[i].R;        if(Q[i].que &lt; L || Q[i].que &gt; R)        {            ans[Q[i].id] = 1;            continue;        }        while(Y &lt; R)            modify(A[++Y], 1);        while(Y &gt; R)            modify(A[Y--], -1);        while(X &lt; L)            modify(A[X++], -1);        while(X &gt; L)            modify(A[--X], 1);        ans[Q[i].id] = (query(A[Q[i].que]) == Q[i].que - L + 1);    }    for(int i = 1; i &lt;= m; ++i)        printf(ans[i] ? "Yes\n" : "No\n");    return 0;}</pre><h4 id="整体二分"><a href="#整体二分" class="headerlink" title="整体二分"></a>整体二分</h4><p>本蒟蒻第一次写整体二分，按照自己的思路瞎b写的，写得丑不要取笑!</p><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#define MAXN 10500#define lowbit(x) (x&-x) int pos[MAXN], n, m;int L[MAXN], R[MAXN], key[MAXN], ans[MAXN];int tmp1[MAXN], tmp2[MAXN], Q[MAXN], _key[MAXN];int tr[MAXN &lt;&lt; 1];void modify(int x, int delta){    for(; x &lt;= n; x += lowbit(x))    {        tr[x] += delta;    }    return ;} int query(int x){    int ans = 0;    if(x == 0)    {        return 0;    }    for(; x; x -= lowbit(x))    {        ans += tr[x];    }    return ans;}void _r(int& x) {    char c = getchar();    while(c &lt; '0' || c &gt; '9')     {        c = getchar();    }    for(x = 0; c &gt;= '0' && c &lt;= '9'; c = getchar())     {        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0';    }    return ;}void solve(int _L, int _R, int st, int ed){    if(_R == _L)    {        for(int i = st; i &lt;= ed; ++i)        {            ans[Q[i]] = _L;        }        return ;    }    int M = (_L + _R) &gt;&gt; 1, c1 = 0, c2 = 0, pp = st;    for(int i = _L; i &lt;= M; ++i)    {        modify(pos[i], 1);    }    for(int i = st, I, delta; i &lt;= ed; ++i)    {        I = Q[i];        if((delta = query(R[I]) - query(L[I] - 1)) &gt;= key[I])        {            tmp1[c1++] = Q[i];        }        else        {            tmp2[c2++] = Q[i];            key[Q[i]] -= delta;        }    }    for(int i = _L; i &lt;= M; ++i)    {        modify(pos[i], -1);    }    for(int i = 0; i &lt; c1; ++i)    {        Q[pp++] = tmp1[i];    }    for(int i = 0; i &lt; c2; ++i)    {        Q[pp++] = tmp2[i];    }    solve(_L, M, st, st+c1-1);    solve(M+1, _R, st+c1, pp-1);    return ;}int main() {    _r(n);    _r(m);    for(int i = 1, x; i &lt;= n; ++i)    {        _r(x);        pos[x] = i;    }    for(int i = 1; i &lt;= m; ++i)    {        _r(L[i]);        _r(R[i]);        _r(_key[i]);        if(_key[i] &gt;= L[i] && _key[i] &lt;= R[i])        {            key[i] = _key[i] - L[i] + 1;        }        else        {            key[i] = 1;        }        Q[i] = i;    }    solve(1, n, 1, m);    for(int i = 1; i &lt;= m; ++i)    {        if(_key[i] &gt;= L[i] && _key[i] &lt;= R[i])        {            if(pos[ans[i]] == _key[i])            {                printf("Yes\n");            }            else            {                printf("No\n");            }        }        else        {            printf("Yes\n");        }    }    return 0;}</pre><h2 id="1594-求和"><a href="#1594-求和" class="headerlink" title="1594.求和"></a>1594.求和</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1594" target="_blank" rel="noopener">1594</a></p><h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>此题一语双关<br>题目背景是割地求和<br>于是做法也自然是求和</p><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p>二维前缀和<br>不过这个题的数据范围有诈，给的不是n，m的范围，而是n*m的范围。<br>不知道实际数据如何，但保险起见还是动态开辟二维数组吧。</p><h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#include &lt;cstdlib&gt;int n, m, q;void _r(int& x){    char c = getchar();    while(c &lt; '0' || c &gt; '9')        c =getchar();    for(x = 0; c &gt;= '0' && c &lt;= '9'; c = getchar())        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0';    return ;}int main(){    _r(n);    _r(m);    _r(q);    long long** summ = (long long**) malloc(sizeof(long long*) * (n + 2));    for(int i = 0; i &lt;= n + 1; ++i)    {        summ[i] = (long long*) malloc(sizeof(long long) * (m + 2));        for(int j = 0; j &lt;= m + 1; ++j)            summ[i][j] = 0;    }    for(int i = 1; i &lt;= n; ++i)        for(int j = 1, x; j &lt;= m; ++j)        {            _r(x);            summ[i][j] = summ[i-1][j] + summ[i][j-1] - summ[i-1][j-1] + x;        }    for(int i = 1, a, b, c, d; i &lt;= q; ++i)    {        _r(a); _r(b); _r(c); _r(d);        printf("%lld\n", summ[c][d] - summ[a-1][d] - summ[c][b-1] + summ[a-1][b-1]);    }    return 0;}    </pre><h2 id="4206-Strict-Yan涂色"><a href="#4206-Strict-Yan涂色" class="headerlink" title="4206. Strict Yan涂色"></a>4206. Strict Yan涂色</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/4206" target="_blank" rel="noopener">4206</a></p><h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>修改部分格子的颜色，使之能够被分成若干k*k的颜色相同的小块。<br>要求最少化修改操作。</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>暴力模拟就行了。<br>因为$$\sum_{k=2}^{+\infty}{\frac{1}{k^2}}=\frac{\pi^2}{6}-1$$<br>所以效率是O(nm)的</p><h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#define MAXN 2050int cnt[MAXN][MAXN];int n, m, n2, m2, mx, cc, ans, k2;char str[2050];inline int Cnt(int a, int b, int c, int d){    return cnt[c][d] - cnt[c][b-1] - cnt[a-1][d] + cnt[a-1][b-1];}int main(){    scanf("%d%d", &n, &m);    ans = n * m;    mx = (m &gt; n ? m : n);    n2 = (mx &lt;&lt; 1); m2 = (mx &lt;&lt; 1);    for(int i = 1; i &lt;= n; ++i)    {        scanf("%s", str + 1);        for(int j = 1; j &lt;= m; ++j)            cnt[i][j] = cnt[i-1][j] + cnt[i][j-1] - cnt[i-1][j-1] + str[j] - '0';        for(int j = m + 1; j &lt;= m2; ++j) cnt[i][j] = cnt[i][j-1];    }    for(int i = n + 1; i &lt;= n2; ++i)        for(int j = 1; j &lt;= m2; ++j)            cnt[i][j] = cnt[i-1][j];    for(int k = 2; k &lt;= mx; ++k)    {        cc = 0;        k2 = k * k;        for(int i = 1; i &lt;= n; i += k)            for(int j = 1, tmp; j &lt;= m; j += k)            {                tmp = Cnt(i, j, i + k - 1, j + k - 1);                cc += ((tmp &lt;&lt; 1) &lt; k2 ? tmp : k2- tmp);            }        ans = ans &gt; cc ? cc : ans;    }    printf("%d\n", ans);    return 0;}</pre><h2 id="3030-mushroom"><a href="#3030-mushroom" class="headerlink" title="3030.mushroom"></a>3030.mushroom</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/3030" target="_blank" rel="noopener">3030</a></p><h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>有限物品的背包</p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>裸背包，动规搞定</p><h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;int f[1200], T, M;int main(){    scanf("%d%d", &T, &M);    for(int i = 1, x, y; i &lt;= M; ++i)    {        scanf("%d%d", &x, &y);        for(int j = T; j - x &gt;= 0; --j)            f[j] = f[j] &gt; f[j - x] + y ? f[j] : f[j - x] + y;    }    int ans = 0;    for(int j = 0; j &lt;= T; ++j)        ans = ans &gt; f[j] ? ans : f[j];    printf("%d\n", ans);    return 0;}</pre><h2 id="4025-洪水来袭"><a href="#4025-洪水来袭" class="headerlink" title="4025.洪水来袭"></a>4025.洪水来袭</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/4025" target="_blank" rel="noopener">4025</a></p><h3 id="题目大意-7"><a href="#题目大意-7" class="headerlink" title="题目大意"></a>题目大意</h3><p>已知一个底部不均匀的容器的底部深度分布情况，求解某一体积的液体对应的液面高度。</p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>二分答案</p><h3 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAXN 505void _r(int& x){    char c = getchar();    while(c &lt; '0' || c &gt; '9')        c = getchar();    for(x = 0; c &gt;= '0' && c &lt;= '9'; c = getchar())        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0';    return ;}int n, m;double A[MAXN][MAXN];double V;const double eps = 1e-4;bool ok(double H){    double _V = 0;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= m; ++j)            if(A[i][j] &lt; H)                _V += H - A[i][j];    return _V &gt;= V;}int main(){    _r(n);    _r(m);    for(int i = 1; i &lt;= n; ++i)        for(int j = 1, x; j &lt;= m; ++j)        {            _r(x);            A[i][j] = 1.0 * x;        }    scanf("%lf", &V);    double L = 0, R = 1e10, M;    while(fabs(R - L) &gt; eps)    {        M = (L + R) * 0.5;        if(ok(M))            R = M;        else            L = M;    }    printf("%.02lf\n", M);    int cnt = 0;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= m; ++j)            cnt += A[i][j] &lt; (M - eps);    printf("%.02lf\n", 100.0 * cnt / (1.0 * n * m));    return 0;}</pre><h2 id="4116-刀位分配"><a href="#4116-刀位分配" class="headerlink" title="4116.刀位分配"></a>4116.刀位分配</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/4116" target="_blank" rel="noopener">4116</a></p><h3 id="题目大意-8"><a href="#题目大意-8" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一维数轴上的N个点的坐标，要从这N个点中选中S个点，要求这些点两两之间的距离<br>不少于d。求这个d的最大值。</p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>二分答案，显然满足二分性质。</p><h3 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 105000void _r(int& x){    char c = getchar();    while(c &lt; '0' || c &gt; '9')        c = getchar();    for(x = 0; c &gt;= '0' && c &lt;= '9'; c = getchar())         x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + c - '0';}int pos[MAXN], n, S;int cal(int dis){    int pre = -dis - 1, cnt = 0;    for(int i = 1; i &lt;= n; ++i)    {        if(pos[i] - pre &gt;= dis)        {             ++cnt;            pre = pos[i];        }        if(cnt &gt;= S)            return 1;     }    return 0;}int main(){    _r(n); _r(S);    for(int i = 1; i &lt;= n; ++i)        _r(pos[i]);    sort(pos + 1, pos + n + 1);    int L = 0, R = pos[n] - pos[1], M;    while(L &lt;= R)    {        M = (L + R) &gt;&gt; 1;        if(cal(M))            L = M + 1;        else             R = M - 1;    }    printf("%d\n", R);    return 0;}</pre><h2 id="1992-绮礼的阴谋"><a href="#1992-绮礼的阴谋" class="headerlink" title="1992.绮礼的阴谋"></a>1992.绮礼的阴谋</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1992" target="_blank" rel="noopener">1992</a></p><h3 id="题目大意-9"><a href="#题目大意-9" class="headerlink" title="题目大意"></a>题目大意</h3><p>求若干区间并集的长度</p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>按左端点优先进行排序，逐次拓展并集。</p><h3 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 10500struct node{    long long L, R;    node(){};    node(long long _l, long long _r)    {        L = _l;        R = _r;    }}A[MAXN];bool cmp(node a, node b){    if(a.L == b.L)        return a.R &lt; b.R;    return a.L &lt; b.L;}int n;long long Left, Right, ans = 0;int main(){    scanf("%d", &n);    long long xx, yy;    for(int i = 1; i &lt;= n; ++i)    {        scanf("%lld%lld", &xx, &yy);        A[i] = node(xx, yy);    }    sort(A + 1, A + n + 1, cmp);    Left = A[1].L; Right = A[1].R;    for(int i = 2; i &lt;= n; ++i)    {        if(A[i].L &lt;= Right)            Right = Right &gt; A[i].R ? Right : A[i].R;        else        {            ans += Right - Left;            Left = A[i].L;            Right = A[i].R;        }    }    ans += Right - Left;    printf("%lld\n", ans);    return 0;}</pre><h2 id="4053-Prime-Ring"><a href="#4053-Prime-Ring" class="headerlink" title="4053.Prime Ring"></a>4053.Prime Ring</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/4053" target="_blank" rel="noopener">4053</a></p><h3 id="题目大意-10"><a href="#题目大意-10" class="headerlink" title="题目大意"></a>题目大意</h3><p>求1~n的圆排列，使得圆上相邻两数之和为素数。$1\leq n \leq 16$</p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p>裸搜索，不加剪枝也能过，交大机子很快的</p><h3 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h3><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;int prime[11] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};int p[20], n, used[20], flag = 0;void work(int k){    if(k == n + 1)    {        for(int i = 0; i &lt; 11; ++i)        {                if(p[n] + 1 == prime[i])            {                for(int i = 1; i &lt;= n; ++i)                {                    printf("%d ", p[i]);                }                putchar('\n');                flag = 1;                return ;            }        }        return ;    }    for(int i = 0; i &lt; 11 && prime[i] - p[k-1] &lt;= n; ++i)    {        if(prime[i] &gt; p[k - 1] && !used[prime[i] - p[k - 1]])        {            used[prime[i] - p[k - 1]] = 1;            p[k] = prime[i] - p[k-1];            work(k + 1);            used[prime[i] - p[k - 1]] = 0;        }    }    return ;}int main(){    //freopen("data.txt", "w", stdout);    scanf("%d", &n);    p[1] = 1;    used[1] = 1;    work(2);    if(!flag)        printf("None\n");    return 0;}</pre><h2 id="1034-二哥的金链"><a href="#1034-二哥的金链" class="headerlink" title="1034.二哥的金链"></a>1034.二哥的金链</h2><p><a href="https://acm.sjtu.edu.cn/OnlineJudge/problem/1034" target="_blank" rel="noopener">1034</a></p><h3 id="题目大意-11"><a href="#题目大意-11" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个圆环以及圆环上的若干个数。对于每一个长度为k的区间，取区间内<br>圆环上的数的最大值，求所有这些最大值中最小的那个值。</p><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>单调队列，经典的滑动窗口模型。<br>队列里面按照下标递增高度递减的方式维护当前考虑的区间里的数。<br>正确性可以由一个简单的贪心原则说明：对于位置靠后的数，如果比位置靠前的数更大，<br>那么位置靠前的数出队列。因为当靠后的数位于当前考虑的区间时，由于它更大，故而<br>靠前的数不可能成为最大值；而当靠后的数不位于当前考虑区间时，靠前的数也不位于<br>考虑区间内(事实上靠前的数更早离开考虑区间)，也不可能是最大值。<br>每次进行下列三个操作：</p><ol><li>将不在区间里面的数，剔除(小于考虑范围的左界，而且每次至多剔除一个，且只可能剔除队首元素)</li><li>将右边界处的新加入元素入队，并维护单调性</li><li>取队列中最大元素(根据单调性，是队首元素)<h5 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h5><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#define MAXN 200500int A[MAXN &lt;&lt; 1], n, k;int Q[MAXN], hh = 1, tt = 0;void _r(int& x){ char c = getchar(); while(c &lt; '0' || c &gt; '9') {     c = getchar(); } for(x = 0; c &gt;= '0' && c &lt;= '9'; c = getchar()) {     x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0'; } return ;}inline int minn(int a, int b){ return a &lt; b ? a : b;}void push(int x){ while(hh &lt;= tt && A[Q[tt]] &lt;= A[x]) {     --tt; } Q[++tt] = x; return ;}int main(){ _r(n); _r(k); for(int i = 1; i &lt;= n; ++i) {     _r(A[i]);     A[i + n] = A[i];     if(i &lt;= k)     {         push(i);     } } int ans = A[Q[hh]]; for(int i = 2; i &lt;= n; ++i) {     if(Q[hh] &lt; i)     {         ++hh;     }     push(i + k - 1);     ans = minn(ans, A[Q[hh]]); } printf("%d\n", ans); return 0;}</pre></li></ol><h4 id="稀疏表ST-Sparse-Table"><a href="#稀疏表ST-Sparse-Table" class="headerlink" title="稀疏表ST(Sparse Table)"></a>稀疏表ST(Sparse Table)</h4><p>经典算法，倍增的思想<br>用$Max[k][i]$ 表示区间$[i,i+2^k)$的最值<br>求Max用倍增思想:$Max[k+1][i] = max(Max[k][i], Max[k][i+(1&lt;&lt;k)])$<br>求解区间 [L,R] 最值则可用两段区间去覆盖</p><h5 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h5><pre style="color:White;bgcolor:Black">#include &lt;cstdio&gt;#define MAXN 205000 int n, k ,n2;void _r(int& x){    char c = getchar();    while(c &lt; '0' || c &gt; '9')    {        c = getchar();    }    for(x = 0; c &gt;= '0' && c &lt;= '9'; c = getchar())    {        x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - '0';    }    return ;}int A[MAXN &lt;&lt; 1];int M[22][MAXN &lt;&lt; 1];inline int maxn(int a, int b){    return a &gt; b ? a : b;}inline int minn(int a, int b){    return a &lt; b ? a : b;}int main(){    int ans = 0;    _r(n);     n2 = (n &lt;&lt; 1);    _r(k);    for(int i = 1; i &lt;= n; ++i)    {        _r(A[i]);        ans = maxn(ans, A[i]);        A[i + n] = A[i];        M[0][i] = M[0][i + n] = A[i];    }    for(int kk = 1, L; kk &lt;= 19; ++kk)    {        L = (1 &lt;&lt; (kk - 1));        for(int i = 1; i + L &lt;= n2; ++i)        {            M[kk][i] = maxn(M[kk-1][i], M[kk-1][i+L]);        }    }    int cnt = 0, L;    for(int i = k; i; i &gt;&gt;= 1)    {        ++cnt;    }    cnt -= 1;    L = (1 &lt;&lt; cnt);    for(int i = 1, mx; i &lt;= n; ++i)    {        mx = maxn(M[cnt][i], M[cnt][i + k - L]);        ans = minn(ans, mx);    }    printf("%d\n", ans);    return 0;}</pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈FFT</title>
      <link href="/2019/03/22/article0005/"/>
      <url>/2019/03/22/article0005/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lym01803/article/details/62891985" target="_blank" rel="noopener">传送门</a></p><h2 id="基础知识浅谈"><a href="#基础知识浅谈" class="headerlink" title="基础知识浅谈"></a><strong>基础知识浅谈</strong></h2><h3 id="FFT—快速傅里叶变换"><a href="#FFT—快速傅里叶变换" class="headerlink" title="FFT—快速傅里叶变换"></a><strong>FFT—快速傅里叶变换</strong></h3><h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a><strong>基本功能</strong></h4><p>在O( (n+m)log(n+m) )的时间复杂度内计算：n次多项式乘m次多项式.</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><p>欲求多项式A_多项式B：<br>1.对多项式A，B分别进行快速傅里叶变换,得到A1,B1;<br>2.将A1,B1的<strong>对应项</strong>相乘得到多项式C1.即：C1[i]=A1[i]_B1[i]  其中C1[i]表示C1的第i项系数.<br>3.将多项式C1进行逆变换得到多项式C.则多项式C即是多项式A与多项式B相乘的结果.<br>具体证明这里不多说了.</p><h3 id="NTT—快速数论变换"><a href="#NTT—快速数论变换" class="headerlink" title="NTT—快速数论变换"></a><strong>NTT—快速数论变换</strong></h3><h4 id="基本功能-1"><a href="#基本功能-1" class="headerlink" title="基本功能"></a><strong>基本功能</strong></h4><p>与FFT类似，但没有精度差.</p><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h4><p>与FFT类似，只是用数论原根的幂代替FFT中的w[n].</p><h5 id="原根的含义及求法"><a href="#原根的含义及求法" class="headerlink" title="原根的含义及求法"></a><strong>原根的含义及求法</strong></h5><p>根据欧拉定理，若a,p互质则有：<br>$$a^{\phi(p)}≡1\  \ (mod\ \ p)$$<br>如果当且仅当$x=\phi(p)$ 时$$a^{x}≡1\ \ (mod\ \ p)$$<br>则a是p的一个原根.<br>用更专业的语言来描述即：a模p的阶等于$\phi(p)$ 则a是p的原根.<br>原根的求法：没有什么特别的方法，只能暴力枚举，验证时略有技巧，这里就不细说了.</p><h3 id="关于NTT算法的一些说明"><a href="#关于NTT算法的一些说明" class="headerlink" title="关于NTT算法的一些说明"></a><strong>关于NTT算法的一些说明</strong></h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><p>相比起FFT来说，NTT最显著的优势在于没有精度差.由于FFT会用到complex double ,在大数据下不排除出现精度差的可能.在某些评测机上，效率可能不如NTT.(NTT虽然不用复数运算，但是取模很多).</p><h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a><strong>限制</strong></h4><p>相比起FFT来说,NTT的限制很多.</p><ul><li>所求的多项式要求是整系数</li><li>如果题目要求结果对质数p取模,这个质数往往只能是998244353，否则会有很多麻烦，这个会在后面谈到.</li><li>所求多项式的项数应在$2^{23}$ 之内,因为$998244353=7_17_2^{23}+1$ </li><li>结果的系数不应超过质数P.(P是自己选择的质数,一般定为P=998244353)</li></ul><h3 id="具体代码实现"><a href="#具体代码实现" class="headerlink" title="具体代码实现"></a><strong>具体代码实现</strong></h3><h4 id="FFT模板"><a href="#FFT模板" class="headerlink" title="FFT模板"></a><strong>FFT模板</strong></h4><pre><code>const double pi=3.1415926535897932384626433832795;complex&lt;double&gt;Wi[MAXN];char s[MAXN],t[MAXN];void FFT(complex&lt;double&gt; A[],int nn,int ty){    int i,j,k,m;    complex&lt;double&gt; t0,t1;    for(i=0;i&lt;nn;i++)    {        for(j=0,k=i,m=1;m&lt;nn;m&lt;&lt;=1,j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1);        if(i&lt;j)t0=A[i],A[i]=A[j],A[j]=t0;    }//这段for循环不建议擅自改动,极易出错.    Wi[0]=1;    for(m=1;m&lt;nn;m&lt;&lt;=1)    {        t0=exp(complex&lt;double&gt;(0,ty*pi/m));        for(i=1;i&lt;m;i++)            Wi[i]=Wi[i-1]*t0;        for(k=0;k&lt;nn;k+=m&lt;&lt;1)            for(i=k;i&lt;k+m;i++)            {                t0=A[i];                t1=A[i+m]*Wi[i-k];                A[i]=t0+t1;                A[i+m]=t0-t1;            }    }    if(ty==1)        return;//ty==-1时为逆变换.    t0=1.0/nn;    for(i=0;i&lt;nn;i++)        A[i]*=t0;}</code></pre><h4 id="NTT模板"><a href="#NTT模板" class="headerlink" title="NTT模板"></a><strong>NTT模板</strong></h4><pre><code>const int P=998244353;const int g=3;//P的原根int W[MAXN];int exp(int a,int k){    ll A=1LL*a,ANS=1LL;    for(;k;k&gt;&gt;=1,A=A*A%P)    {        if(k&amp;1)        {            ANS=ANS*A%P;        }    }    return (int)ANS%P;}//其实这里的函数名取为exp是不恰当的，不过无伤大雅.void NTT(int A[],int nn,int ty){    int t1,t2,i,j,k,m;    for(i=0;i&lt;nn;i++)    {        for(j=0,k=i,m=1;m&lt;nn;m&lt;&lt;=1,j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1);        if(i&lt;j)        {            t1=A[i];            A[i]=A[j];            A[j]=t1;        }    }    W[0]=1;    for(m=1;m&lt;nn;m&lt;&lt;=1)    {        t1=exp(g,P-1+ty*(P-1)/(m&lt;&lt;1));        for(i=1;i&lt;m;i++)        {            W[i]=1LL*W[i-1]*t1%P;        }        for(k=0;k&lt;nn;k+=m&lt;&lt;1)        {            for(i=k;i&lt;k+m;i++)            {                t1=A[i];                t2=1LL*A[i+m]*W[i-k]%P;                A[i]=t1+t2;                A[i]-=A[i]&gt;P?P:0;                A[i+m]=t1-t2;                A[i+m]+=A[i+m]&lt;0?P:0;            }        }    }    if(ty==1)    {        return ;    }    t1=exp(nn,P-2);    for(i=0;i&lt;nn;i++)    {        A[i]=1LL*A[i]*t1%P;    }    return ;}</code></pre><h2 id="FFT及NTT的简单应用"><a href="#FFT及NTT的简单应用" class="headerlink" title="FFT及NTT的简单应用"></a><strong>FFT及NTT的简单应用</strong></h2><h3 id="最基本应用–高精度乘法"><a href="#最基本应用–高精度乘法" class="headerlink" title="最基本应用–高精度乘法"></a><strong>最基本应用–高精度乘法</strong></h3><p>将十进制数看成一个多项式,然后利用FFT或NTT求解.(注意进位).<br>比如：<br>123_456=56088可以看成:<br>$$123=1_10^{2}+2_10^{1}+3_10^{0}$$<br>$$456=4_10^{2}+5_10^{1}+6_10^{0}$$<br>$$123_456=4_10^{4}+13_10^{3}+28_10^{2}+27_10^{1}+18_10^{0}$$<br>考虑进位则有：<br>$$123_456=5_10^{4}+6_10^{3}+0_10^{2}+8_10^{1}+8*10^{0}=56088$$</p><h3 id="稍微高端一点的应用"><a href="#稍微高端一点的应用" class="headerlink" title="稍微高端一点的应用"></a><strong>稍微高端一点的应用</strong></h3><h4 id="特殊的计数问题"><a href="#特殊的计数问题" class="headerlink" title="特殊的计数问题"></a><strong>特殊的计数问题</strong></h4><h5 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h5><p>给出两个长度分别为n,m的01序列A、B，有Q次询问，每次询问要求回答：当把A的第i位和B的第j位对齐时，A,B公共部分有多少对对齐且相同的数.<br>如：<br>输入n,m,A串,B串,Q,每次询问(i,j)<br>6 6<br>000111<br>111100<br>3<br>1 1<br>1 2<br>4 2<br>输出每次询问的答案:<br>1<br>0<br>3</p><h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围:"></a>数据范围:</h5><p>n&lt;=100000,Q&lt;=1000000</p><h5 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h5><p>注意到所有询问总共只有2n-1种本质不同的询问,我们希望预处理出所有这些本质不同的询问的答案.<br>比如询问为(i,j)我们可以等价转化为(1,j-i)，因此我们不妨将询问设为(1,k)<br>我们先考虑有多少位上的1是对齐的：<br>其实两个位置上的1对齐,当且仅当两个位置都是1,且两个位置相差k-1.<br>如果将其中一个序列倒序排列的话，那么两个之前对齐的位置现在的位置标号之和就是定值了.于是就可以构造多项式进行计数.<br>这之后，我们将所有0，1取反,就可以同样计算出有多少位0是对齐的.</p><h5 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h5><pre><code>#include&lt;cstdio&gt;#include&lt;cstring&gt; #define MAXN 425000const int P=998244353;const int G=3;char sa[MAXN],sb[MAXN];int N,W[MAXN*2];void _r(int&amp; x){    char c=getchar();    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)    {        c=getchar();    }    for(x=0;c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;;c=getchar())    {        x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;    }    return ;}bool check(int x[],int nn){    for(int i=0;i&lt;nn;i++)    {        if(x[i])        {            return false;        }    }    return true;}int CNT[MAXN*2];int exp(int a,int k){    int ans=1;    for(;k;k&gt;&gt;=1)    {        if(k&amp;1)        {            ans=1ll*ans*a%P;        }        a=1ll*a*a%P;    }    return ans;}void fft(int A[],int nn,int ty){    int t1,t2,i,j,k,m;    for(i=0;i&lt;nn;i++)    {        for(j=0,k=i,m=1;m&lt;nn;m&lt;&lt;=1,j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1);        if(i&lt;j)        {            t1=A[i];            A[i]=A[j];            A[j]=t1;        }    }    W[0]=1;    for(m=1;m&lt;nn;m&lt;&lt;=1)    {        t1=exp(G,P-1+ty*(P-1)/(m&lt;&lt;1));        for(i=1;i&lt;m;i++)        {            W[i]=1ll*W[i-1]*t1%P;        }        for(k=0;k&lt;nn;k+=m&lt;&lt;1)        {            for(i=k;i&lt;k+m;i++)            {                t1=A[i];                t2=1ll*A[i+m]*W[i-k]%P;                A[i]=t1+t2;                A[i]-=A[i]&gt;P?P:0;                A[i+m]=t1-t2;                A[i+m]+=A[i+m]&lt;0?P:0;            }        }    }    if(ty==1)    {        return ;    }    t1=exp(nn,P-2);    for(i=0;i&lt;N;i++)    {        A[i]=1ll*A[i]*t1%P;    }    return ;}//其实是NTT只是函数名取成了fftint A[MAXN*2],B[MAXN*2],n,m,q;int o[12],tot=0;void PUT(int x){    if(x==0)    {        putchar(&#39;0&#39;);        return ;    }    for(tot=0;x;x/=10)    {        o[++tot]=x%10;    }    for(;tot;tot--)    {        putchar(o[tot]+&#39;0&#39;);    }    return ;}int main(){    _r(n);    _r(m);    scanf(&quot;%s%s&quot;,sa,sb);    for(int i=0;i&lt;n;i++)    {        A[i]=sa[i]-&#39;0&#39;;    }    for(int i=0;i&lt;m;i++)    {        B[i]=sb[m-i-1]-&#39;0&#39;;    }    for(N=1;N&lt;n+m+1;N&lt;&lt;=1);    if(check(A,N)||check(B,N));//特判两个多项式是否存在为0的,否则用NTT会有诈.    else    {        fft(A,N,1);        fft(B,N,1);        for(int i=0;i&lt;N;i++)        {            A[i]=1ll*A[i]*B[i]%P;        }        fft(A,N,-1);        for(int i=0;i&lt;N;i++)        {            CNT[i]+=A[i];        }    }    memset(A,0,sizeof(A));    memset(B,0,sizeof(B));    for(int i=0;i&lt;n;i++)    {        A[i]=sa[i]-&#39;0&#39;;        A[i]^=1;    }    for(int i=0;i&lt;m;i++)    {        B[i]=sb[m-i-1]-&#39;0&#39;;        B[i]^=1;    }    if(check(A,N)||check(B,N));    else    {         fft(A,N,1);        fft(B,N,1);        for(int i=0;i&lt;N;i++)        {            A[i]=1ll*A[i]*B[i]%P;        }        fft(A,N,-1);        for(int i=0;i&lt;N;i++)        {            CNT[i]+=A[i];        }    }     _r(q);    for(int i=1,u,v;i&lt;=q;i++)    {        _r(u);        _r(v);        int p=u-1+m-v;        PUT(CNT[p]);        putchar(&#39;\n&#39;);    }    return 0;} </code></pre><p>还有一道很牛逼的题目—万径人踪灭,也用到了这个方法.</p><h2 id="NTT-amp-FFT与多项式问题"><a href="#NTT-amp-FFT与多项式问题" class="headerlink" title="NTT&amp;FFT与多项式问题"></a><strong>NTT&amp;FFT与多项式问题</strong></h2><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a><strong>相关知识</strong></h3><ul><li>多项式求逆</li><li>多项式除法</li><li>多项式取模</li><li>多项式开方</li><li>多项式快速幂</li><li>多项式取对数</li><li>………………</li></ul><p>这些东西本人也是一知半解，具体算法的证明过程，代码实现可以参考网上的其他博客。这里给一个参考的链接(_加载非常慢，但内容非常好，如有需要请耐心等待_):<a href="http://picks.logdown.com/posts/197262-polynomial-division" target="_blank" rel="noopener">http://picks.logdown.com/posts/197262-polynomial-division</a></p><h3 id="简单地谈一谈"><a href="#简单地谈一谈" class="headerlink" title="简单地谈一谈"></a><strong>简单地谈一谈</strong></h3><h4 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a><strong>多项式求逆</strong></h4><p>已知多项式A,欲求多项式B,使$A_ B≡1\ (mod\  x^{n})$.<br>首先,常数项取$B[0]=A[0]^{-1}$<br>假如我们已经得到B’，使得$A_B’≡1\ (mod\ x^{n})$,欲求B使得$A_B≡1\ (mod\ x^{2n})$<br>那么有$$A_(B-B’)≡0\ (mod\ x^n)$$<br>于是$$B-B’≡0\ (mod\ x^n)$$<br>平方$$B^2+B’^2-2B_B’≡0\ (mod\ x^{2n})$$<br>同时乘A得$$A_B^2+A_B’^2-2A_B_B’≡0\ (mod\ x^{2n})$$<br>即$$B+A_B’^2-2B’≡0\ (mod\ x^{2n})$$<br>于是得到$$B≡2B’-A*B’^2\ (mod\ x^{2n})$$<br>这里用到了倍增的思想.<br>多项式开方与之类似.<br>时间复杂度$$T(n)=T(n/2)+O(nlog\ n),即O(nlog\ n)$$</p><h2 id="一些典型题目"><a href="#一些典型题目" class="headerlink" title="一些典型题目"></a><strong>一些典型题目</strong></h2><h3 id="贝壳串"><a href="#贝壳串" class="headerlink" title="贝壳串"></a><strong>贝壳串</strong></h3><p>【问题描述】<br>海边市场有长度分别为1到n的贝壳串出售，其中长度为i的贝壳串有a[i]种，每种贝壳串有无限个，问用这些贝壳串链接成长度为n的串有多少种方案?</p><p>【输入格式】<br>第一行，一整数n，<br>第二行，n个整数ai表示长度为i的贝壳串的种类数</p><p>【输出格式】<br>输出方案数，结果模313</p><p>【输入输出样例】<br>in<br>3<br>1 3 7<br>out<br>14</p><p>in<br>4<br>2 2 2 2<br>out<br>54</p><p>int<br>7<br>86 58 87 145 510 32 263<br>out<br>152<br>【数据范围】<br>对于50%的数据n&lt;=1000<br>对于100%的数据n&lt;=100000，0&lt;=ai&lt;=10000000</p><h4 id="官方题解"><a href="#官方题解" class="headerlink" title="官方题解"></a><strong>官方题解</strong></h4><p>FFT+分治</p><h4 id="另解"><a href="#另解" class="headerlink" title="另解"></a><strong>另解</strong></h4><p>FFT+多项式求逆</p><h4 id="然而我是一个异端"><a href="#然而我是一个异端" class="headerlink" title="然而我是一个异端"></a><strong>然而我是一个异端</strong></h4><p>题目要求对<strong>313</strong>取模,本是断绝了NTT的路,但我硬是强用NTT把这个题过了！<br>做法非常的<strong>“淫荡”</strong>.为此我专门写了一篇题解：</p><h4 id="另类题解"><a href="#另类题解" class="headerlink" title="另类题解"></a><strong>另类题解</strong></h4><p>【贝壳串shell】的另类解法—-<strong>强行NTT</strong>.</p><p>1.DP方程<br>设f[i]为配成长度为i的项链的方案数,a[i]表示长度为i的贝壳的种类数.<br>枚举最后一串贝壳的长度,可得转移方程：<br>$$f[i]=\sum_{i=1}^{n}f[n-i]\cdot a[i]$$<br>并规定$f[0]=1$.<br>直接暴力DP可以拿到50分.</p><p>2.构造母函数<br>$$F(x)=\sum_{i=0}^{+∞}f[i]\cdot x^i\ \ \ \ \ \ \ \ A(x)=\sum_{i=0}^{+∞}a[i]\cdot x^i$$<br>于是根据dp方程有:$$F(x)=F(x)*A(x)+1$$<br>等价于:$$F(x)=\frac{1}{1-A(x)}$$<br>到此为止用FFT就足以解决问题了.</p><p><strong>3.强用NTT</strong><br>我们知道，多项式求逆需要多次使用NTT，这样不可避免地会使系数对质数P(P=998244353)取模.但是题目要求对313取模,这样得到的答案就不对了.</p><p>举个例子吧：<br>用NTT计算(1+x)^n的一次项系数,答案对9973取模.如果我们直接把多项式进行(n-1)次乘法,那么得到的结果将是n%998244353%9973，这与n%9973是不等价的.<br>但是如果在每次乘以(x+1)后,将结果的各项系数都对9973取模,得到的将是正确的结果.因为NTT实际上是在大质数的<strong>剩余系</strong>下进行乘法运算,如果单次NTT变换的结果不会超出大质数,所得结果将与正常的乘法一样.</p><p>所以，贝壳串这道题也可以使用这样的办法.</p><p>很遗憾的是,就贝壳串一题而言,单次运算的上界=313_313_100000,大约100亿左右,显然超出了998244353之类的数的范围，怎么办？</p><p>我们可以在P=998244353*1004535809的剩余系下完成乘法。(998244353,1004535809都是常见的用于NTT的大质数,本人更喜欢用前者.）我们可以在每次NTT之后都把系数对313取模,这样中间过程一直都不会超过P.</p><p>但是P=998244353*1004535809不能直接用于NTT，于是我们可以把多项式分别在998244353，1004535809的剩余系下进行NTT变换,之后用中国剩余定理求出系数模P的结果.</p><p>不过还有一个坑点,这样得到的结果不一定是真实的结果,不能简单地对313取模.按照以上做法，得到的结果除了可能是真实结果之外,还有可能是(真实结果+P),这时的真实结果是负数.因为在做NTT变换时,负数一般是+P转为正数的.好在负数结果+P的值要远大于正数结果,我们可以很简单区分开二者,然后加以特判即可.<strong>其实这个问题非常容易被忽视！考场上我起初是没有发现这个问题的，调了将近一个小时才发现这个问题。</strong></p><p>至此这个问题终于讲清楚了,贴上我那丑陋的代码！</p><pre><code>//1004535809 998244353#include&lt;cstdio&gt;#define MAXN 450000#define LL long long#define mod 313const int P=998244353,Q=1004535809,G=3;const LL PQ=1ll*998244353*1004535809,lim=1ll*mod*mod*400000;int exp(int a,int k,int MOD){    int an=1;    for(;k;k&gt;&gt;=1)    {        if(k&amp;1)        {            an=1ll*an*a%MOD;        }        a=1ll*a*a%MOD;    }    return an;}const int ip=exp(P,Q-2,Q),iq=exp(Q,P-2,P);int A[MAXN],F[MAXN];int n;void _r(int&amp; x){    char c=getchar();    while(c&lt;&#39;0&#39;||c&gt;&#39;9&#39;)    {        c=getchar();    }    for(x=0;c&gt;=&#39;0&#39;&amp;&amp;c&lt;=&#39;9&#39;;c=getchar())    {        x=(x&lt;&lt;1)+(x&lt;&lt;3)+c-&#39;0&#39;;    }    return ;}void work1(){    F[0]=1;    for(int i=1;i&lt;=n;i++)    {        for(int j=1;j&lt;=i;j++)        {            F[i]=(F[i]+F[i-j]*A[j]%mod)%mod;        }    }    printf(&quot;%d\n&quot;,F[n]);    return ;}int W[MAXN];void NTT(int A[],int nn,int ty,int M){    int i,j,t1,t2,k,m;    for(i=0;i&lt;nn;i++)    {        for(j=0,k=i,m=1;m&lt;nn;m&lt;&lt;=1,j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1);        if(i&lt;j)        {            t1=A[i];            A[i]=A[j];            A[j]=t1;        }    }    W[0]=1;    for(m=1;m&lt;nn;m&lt;&lt;=1)    {        t1=exp(G,M-1+ty*(M-1)/(m&lt;&lt;1),M);        for(i=1;i&lt;m;i++)        {            W[i]=1ll*W[i-1]*t1%M;        }        for(k=0;k&lt;nn;k+=m&lt;&lt;1)        {            for(i=k;i&lt;k+m;i++)            {                t1=A[i];                t2=1ll*A[i+m]*W[i-k]%M;                A[i]=t1+t2;                A[i]-=A[i]&gt;=M?M:0;                A[i+m]=t1-t2;                A[i+m]+=A[i+m]&lt;0?M:0;            }        }    }    if(ty==1)    {        return ;    }    t1=exp(nn,M-2,M);    for(i=0;i&lt;nn;i++)    {        A[i]=1ll*A[i]*t1%M;    }    return ;}LL mul(LL a,LL b){    LL an=0;    for(;b;b&gt;&gt;=1)    {        if(b&amp;1)        {            an=an+a;            an-=an&gt;=PQ?PQ:0;        }        a=a+a;        a-=a&gt;=PQ?PQ:0;    }    return an;}int T1[MAXN],T2[MAXN],tmp[MAXN];void inv(int A[],int X[],int nn){    int i,j,k,t,m,n;    LL t5;    X[0]=exp(A[0],mod-2,mod);    for(m=1;m&lt;nn;m&lt;&lt;=1)    {        n=m&lt;&lt;1;        for(i=0;i&lt;n;i++)        {            T1[i]=A[i];            T2[i]=A[i];        }        for(n&lt;&lt;=1;i&lt;n;i++)        {            T1[i]=0;            T2[i]=0;        }        for(i=0;i&lt;n;i++)        {            tmp[i]=X[i];        }        NTT(T1,n,1,P);        NTT(tmp,n,1,P);        for(i=0;i&lt;n;i++)        {            T1[i]=2+P-1ll*T1[i]*tmp[i]%P;            T1[i]-=T1[i]&gt;=P?P:0;            T1[i]+=T1[i]&lt;0?P:0;            tmp[i]=1ll*tmp[i]*T1[i]%P;        }        NTT(tmp,n,-1,P);        NTT(T2,n,1,Q);        NTT(X,n,1,Q);        for(i=0;i&lt;n;i++)        {            T2[i]=2+Q-1ll*T2[i]*X[i]%Q;            T2[i]-=T2[i]&gt;=Q?Q:0;            T2[i]+=T2[i]&lt;0?Q:0;            X[i]=1ll*X[i]*T2[i]%Q;        }        NTT(X,n,-1,Q);        for(i=0;i&lt;n;i++)        {            t5=(mul(mul(1ll*X[i],1ll*P),1ll*ip)+mul(mul(1ll*tmp[i],1ll*Q),1ll*iq))%PQ;            if(t5&gt;lim)            {                X[i]=t5%mod-PQ%mod;                X[i]+=X[i]&lt;0?mod:0;            }            else            {                X[i]=t5%mod;            }        }        for(i=n&gt;&gt;1;i&lt;n;i++)        {            X[i]=0;        }    }    for(i=nn;i&lt;n;i++)    {        X[i]=0;    }    for(i=0;i&lt;n;i++)    {        tmp[i]=T1[i]=T2[i]=0;    }    return ;}        void work2(){    A[0]=1;    for(int i=1;i&lt;=n;i++)    {        A[i]%=mod;        A[i]=mod-A[i];    }    inv(A,F,n+1);    printf(&quot;%d\n&quot;,(F[n]%mod+mod)%mod);    return ;}int main(){    //freopen(&quot;shell.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;shell.out&quot;,&quot;w&quot;,stdout);    _r(n);    for(int i=1;i&lt;=n;i++)    {        _r(A[i]);    }    if(n&lt;=1100)    {        work1();    }    else    {        work2();    }    return 0;}</code></pre><p>上面的代码很乱，是考场上写的，有很多冗余的变量，将就了看吧.<br>对了,忘记说了，P取得相当大，用中国剩余定理的时候，乘法要用快速乘，不然会超long long.</p><hr><h3 id="小朋友与二叉树"><a href="#小朋友与二叉树" class="headerlink" title="小朋友与二叉树"></a>小朋友与二叉树</h3><p>题目描述参见bzoj 3625 / Codeforces Round #250</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h4><p>这道题是一个计数问题，容易想到dp的做法.<br>设f[n]表示点权和为n的二叉树有多少种.考虑n的组成：<br>左子树点权和+右子树点权和+根节点权值=n.<br>设权值为k的数给定序列中出现次数为c[k],则根据分步计数原理：<br>$$f[n]=\sum _{i+j+k=n}f[i]\cdot f[j]\cdot c[k]$$<br>构造多项式：<br>$$F(x)=\sum _{i=0}^{+∞}f[i]\cdot x^i\ \ \ \ \ \ C(x)=\sum_{i=0}^{+∞}c[i]\cdot x^i$$<br>则有:<br>$$F(x)=F(x)_F(x)_C(x)$$<br>???有诈!!!<br>我们在递推式中默认F(0)=f[0]=1.这样才可以包含子树为空的情形.但是C(0)=c[0]=0.<br>于是F(0)=F(0)_F(0)\_C(0)=C(0)=0,推出矛盾！<br>所以正确的式子：<br>$$F(x)=F(x)_F(x)_C(x)+1$$<br>解得:<br>$$F(x)=\frac {1±\sqrt{1-4C(x)}}{2C(x)}$$<br>这种方程真的能这么解吗？其实只需要知道，把这个解代入原方程，方程肯定成立.我能解释的也只有这么多了.<br>注意到,分母没有常数项，分子要整除分母，则分子也不能有常数项，即±应取负号.<br>为了简单，再做一下变形：<br>$$F(x)=\frac{1±\sqrt{1-4C(x)}}{2C(x)}=\frac{2}{1+\sqrt{1-4C(x)}}$$<br>用多项式开方即可.</p><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a><strong>参考代码</strong></h4><p>算了，这题我就不给代码了！本人2017年3月1日在bzoj提交了这道题，并在当时莫名其妙地超过了各位大牛,拿到了rank 1.如果放出代码，rank 1岂不是保不住了！！！</p><hr><h3 id="bzoj-4555"><a href="#bzoj-4555" class="headerlink" title="bzoj 4555"></a><strong>bzoj 4555</strong></h3><p>第二类斯特林数</p><p>这个题目做法很多,NTT+分治或者多项式求逆都可以做.<br>只要式子化得好,直接上裸的NTT也是可以做的.<br>网上题解很多，这里就不多说了.</p><h4 id="参考代码-不用求逆或分治的常数最小的版本"><a href="#参考代码-不用求逆或分治的常数最小的版本" class="headerlink" title="参考代码(不用求逆或分治的常数最小的版本)"></a><strong>参考代码</strong>(不用求逆或分治的常数最小的版本)</h4><p>这个做法的数学推导比较妙，建议先学习一下第二类斯特林数的展开式.</p><pre><code>#include&lt;cstdio&gt;#define MAXN 410000#define P 998244353#define g 3int n,A[MAXN],B[MAXN],N;int exp(int a,int k,int mod=P){    int an=1;    for(;k;k&gt;&gt;=1)    {        if(k&amp;1)        {            an=1ll*an*a%mod;        }        a=1ll*a*a%mod;    }    return an;}int fac[MAXN],inv[MAXN],W[MAXN];void NTT(int A[],int nn,int ty){    int i,j,k,m,t1,t2;    for(i=0;i&lt;nn;i++)    {        for(j=0,k=i,m=1;m&lt;nn;m&lt;&lt;=1,j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1);        if(i&lt;j)        {            t1=A[i];            A[i]=A[j];            A[j]=t1;        }    }    W[0]=1;    for(m=1;m&lt;nn;m&lt;&lt;=1)    {        t1=exp(g,P-1+ty*(P-1)/(m&lt;&lt;1),P);        for(i=1;i&lt;m;i++)        {            W[i]=1ll*W[i-1]*t1%P;        }        for(k=0;k&lt;nn;k+=m&lt;&lt;1)        {            for(i=k;i&lt;k+m;i++)            {                t1=A[i];                t2=1ll*A[i+m]*W[i-k]%P;                A[i]=t1+t2;                A[i]-=A[i]&gt;=P?P:0;                A[i+m]=t1-t2;                A[i+m]+=A[i+m]&lt;0?P:0;            }        }    }    if(ty==1)    {        return ;    }    t1=exp(nn,P-2,P);    for(i=0;i&lt;nn;i++)    {        A[i]=1ll*A[i]*t1%P;    }    return ;}int main(){    scanf(&quot;%d&quot;,&amp;n);    fac[0]=inv[0]=1;    for(int i=1;i&lt;=n;i++)    {        inv[i]=1ll*inv[i-1]*i%P;        fac[i]=inv[i];    }    inv[n]=exp(inv[n],P-2,P);    for(int i=n;i;i--)    {        inv[i-1]=1ll*inv[i]*i%P;    }    for(int i=0,p;i&lt;=n;i++)    {        if(i&amp;1)        {            A[i]=P-inv[i];        }        else        {            A[i]=inv[i];        }        if(i==0)        {            B[i]=1;        }        else if(i==1)        {            B[i]=1ll*(n+1)*inv[i]%P;        }        else        {            B[i]=1ll*(exp(i,n+1)-1+P)%P*exp(i-1,P-2,P)%P*inv[i]%P;        }    }    for(N=1;N&lt;=n*2;N&lt;&lt;=1);    NTT(A,N,1);    NTT(B,N,1);    for(int i=0;i&lt;N;i++)    {        A[i]=1ll*A[i]*B[i]%P;    }    NTT(A,N,-1);    int ans=0,tmp;    for(int i=0;i&lt;=n;i++)    {        tmp=1ll*exp(2,i,P)*fac[i]%P;        tmp=1ll*tmp*A[i]%P;        ans=ans+tmp;        ans-=ans&gt;=P?P:0;    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><hr><h3 id="【SDOI2013-R1-Day2】淘金"><a href="#【SDOI2013-R1-Day2】淘金" class="headerlink" title="【SDOI2013 R1 Day2】淘金"></a><strong>【SDOI2013 R1 Day2】淘金</strong></h3><h4 id="题目来源：sdoi-2013"><a href="#题目来源：sdoi-2013" class="headerlink" title="题目来源：sdoi 2013"></a>题目来源：sdoi 2013</h4><h4 id="题号：bzoj-3131"><a href="#题号：bzoj-3131" class="headerlink" title="题号：bzoj 3131"></a>题号：bzoj 3131</h4><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>小Z在玩一个叫做《淘金者》的游戏。游戏的世界是一个二维坐标。X轴、Y轴坐标范围均为1..N。初始的时候，所有的整数坐标点上均有一块金子，共N*N块。<br>一阵风吹过，金子的位置发生了一些变化。细心的小Z发现，初始在(i,j)坐标处的金子会变到(f(i),f(j))坐标处。其中f(x)表示x各位数字的乘积，例如f(99)=81，f(12)=2，f(10)=0。如果金子变化后的坐标不在1..N的范围内，我们认为这块金子已经被移出游戏。同时可以发现，对于变化之后的游戏局面，某些坐标上的金子数量可能不止一块，而另外一些坐标上可能已经没有金子。这次变化之后，游戏将不会再对金子的位置和数量进行改变，玩家可以开始进行采集工作。<br>小Z很懒，打算只进行K次采集。每次采集可以得到某一个坐标上的所有金子，采集之后，该坐标上的金子数变为0。<br>现在小Z希望知道，对于变化之后的游戏局面，在采集次数为K的前提下，最多可以采集到多少块金子？<br>答案可能很大，小Z希望得到对1000000007(10^9+7)取模之后的答案。</p><h4 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h4><p>$N\leq 10^{12},k\leq10^5.$</p><h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a><strong>题解</strong></h4><h5 id="一些简单的想法："><a href="#一些简单的想法：" class="headerlink" title="一些简单的想法："></a>一些简单的想法：</h5><ul><li>处理出每个位置的金子数</li><li>如果设g(x)表示所有满足f(i)=x的i的数目，那么(x,y)的金子数为g(x)*g(y)</li><li>如果我们处理出了g(x)的值，那么这就是一个经典的用堆处理的问题了.</li><li>处理g(x)应该可以用数位dp.<h5 id="官方题解：数位dp-堆"><a href="#官方题解：数位dp-堆" class="headerlink" title="官方题解：数位dp+堆."></a>官方题解：数位dp+堆.</h5><h5 id="另一些想法："><a href="#另一些想法：" class="headerlink" title="另一些想法："></a>另一些想法：</h5></li><li>是不是可以暴力求解g(x)?</li><li>g(x)!=0,意味着$x=2^a_3^b_5^c*7^d$，这样的x并不多！</li><li>如果$N\leq10^6$,我们暴力求解即可</li><li>$N\leq10^{12},则N\leq10^6*10^6$我们暴力处理出$10^6$以内的g(x)，然后用NTT做一次乘法就可以得出$10^{12}$以内的g(x)了！</li><li>显然x可以大到$9^{12}$,不过我们可以分解质因数用a,b,c,d存储.为了方便起见，估计a,b,c,d的最大值，然后采取合适的进制就可以了.</li><li>于是这道题居然就可以用NTT+暴力就水过去了！</li><li>当然这个乘法并不简单，考虑到数位dp的特点，我们在做乘法时要分有限制和无限制两部分,具体实现看代码吧<h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a><strong>参考代码</strong></h4>丑的要命的代码：</li></ul><pre><code>#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define MAXN 1080000#define mod 1000000007#define LL long long#define G 998244353#define K 1004535809#define gg 3int exp(int a,int k){    int an=1;    for(;k;k&gt;&gt;=1)    {        if(k&amp;1)        {            an=1ll*an*a%G;        }        a=1ll*a*a%G;    }    return an;}int W[MAXN];void NTT(int A[],int nn,int ty){    int i,j,t1,t2,k,m;    for(i=0;i&lt;nn;i++)    {        for(j=0,k=i,m=1;m&lt;nn;m&lt;&lt;=1,j=(j&lt;&lt;1)|(k&amp;1),k&gt;&gt;=1);        if(i&lt;j)        {            t1=A[i];            A[i]=A[j];            A[j]=t1;        }    }    W[0]=1;    for(m=1;m&lt;nn;m&lt;&lt;=1)    {        t1=exp(gg,G-1+ty*(G-1)/(m&lt;&lt;1));        for(i=1;i&lt;m;i++)        {            W[i]=1ll*W[i-1]*t1%G;        }        for(k=0;k&lt;nn;k+=m&lt;&lt;1)        {            for(i=k;i&lt;k+m;i++)            {                t1=A[i];                t2=1ll*A[i+m]*W[i-k]%G;                A[i]=t1+t2;                A[i]-=A[i]&gt;=G?G:0;                A[i+m]=t1-t2;                A[i+m]+=A[i+m]&lt;0?G:0;            }        }    }    if(ty==1)    {        return ;    }    t1=exp(nn,G-2);    for(i=0;i&lt;nn;i++)    {        A[i]=1ll*A[i]*t1%G;    }    return ;}LL n,k;int f[MAXN],g[MAXN],tot=0,h[MAXN],oto=0;int ans=0;void work1(){    for(int i=1,tt;i&lt;=n;i++)    {        tt=1;        for(int x=i;x;x/=10)        {            tt*=x%10;        }        f[tt]++;    }    for(int i=1;i&lt;=n;i++)    {        if(f[i])        {            g[++tot]=f[i];        }    }    sort(g+1,g+1+tot);    for(int i=tot;i&gt;=1&amp;&amp;i&gt;=tot-1000;i--)    {        for(int j=tot;j&gt;=1&amp;&amp;j&gt;=tot-1000;j--)        {            h[++oto]=1ll*g[i]*g[j]%mod;        }    }    sort(h+1,h+1+oto);    for(int i=oto;i&gt;=1&amp;&amp;i&gt;=oto-k+1;i--)    {        ans+=h[i];        ans-=ans&gt;=mod?mod:0;    }    printf(&quot;%d\n&quot;,ans);    return ;}//分段，前面小数据直接暴力！const int QQ=1000000;LL n1,n2,m1,m2,AA[MAXN*3];int pp[5]={0,2,3,5,7},qq[5]={0,40,26,18,15};int A[MAXN],B[MAXN],C[MAXN],D[MAXN],NN=1048576;struct node{    int x,y;    LL val;    node(int xx=0,int yy=0)    {        x=xx;        y=yy;        val=1ll*D[x]*D[y];    }};bool cmp(LL a,LL b){    return a&gt;b;}bool operator &lt; (node x,node y){    return x.val&lt;y.val;}priority_queue&lt;node&gt;Q;void work2(){    n1=n/QQ;    n2=n1-1;    m1=n%QQ;    m2=QQ-1;    memset(f,0,sizeof(f));     for(int i=QQ/10,tt;i&lt;=m2;i++)    {        tt=1;        for(int x=i;x;x/=10)        {            tt*=x%10;        }        f[tt]++;    }    tot=0;    for(int i=1;i&lt;=m2;i++)    {        if(f[i])        {            int tt=0;            for(int j=4,q=i;j&gt;=1;j--)            {                tt*=qq[j];                while(q%pp[j]==0)                {                    q/=pp[j];                    ++tt;                }            }            D[tt]=f[i];        }    }    memset(f,0,sizeof(f));     for(int i=QQ/10,tt;i&lt;=m1;i++)    {        tt=1;        for(int x=i;x;x/=10)        {            tt*=x%10;        }        f[tt]++;    }    tot=0;    for(int i=1;i&lt;=m1;i++)    {        if(f[i])        {            int tt=0;            for(int j=4,q=i;j&gt;=1;j--)            {                tt*=qq[j];                while(q%pp[j]==0)                {                    q/=pp[j];                    ++tt;                }            }            C[tt]=f[i];        }    }    memset(f,0,sizeof(f));     for(int i=1,tt;i&lt;=n2;i++)    {        tt=1;        for(int x=i;x;x/=10)        {            tt*=x%10;        }        f[tt]++;    }    tot=0;    for(int i=1;i&lt;=n2;i++)    {        if(f[i])        {            int tt=0;            for(int j=4,q=i;j&gt;=1;j--)            {                tt*=qq[j];                while(q%pp[j]==0)                {                    q/=pp[j];                    ++tt;                }            }            B[tt]=f[i];        }    }    int ttt=1;    for(int x=n1;x;x/=10)    {        ttt*=x%10;    }    int tt=0;    if(ttt)    {        for(int j=4,q=ttt;j&gt;=1;j--)        {            tt*=qq[j];            while(q%pp[j]==0)            {                q/=pp[j];                ++tt;            }        }    }    A[tt]=1;    NTT(A,NN,1);    NTT(C,NN,1);    for(int i=0;i&lt;NN;i++)    {        A[i]=1ll*A[i]*C[i]%G;    }    NTT(A,NN,-1);    NTT(B,NN,1);    NTT(D,NN,1);    for(int i=0;i&lt;NN;i++)    {        B[i]=1ll*B[i]*D[i]%G;    }    NTT(B,NN,-1);    for(int i=0;i&lt;NN;i++)    {        C[i]=A[i]+B[i];        C[i]-=C[i]&gt;=mod?mod:0;    }    memset(f,0,sizeof(f));     memset(D,0,sizeof(D));    for(int i=1,tt;i&lt;=m2;i++)    {        tt=1;        for(int x=i;x;x/=10)        {            tt*=x%10;        }        f[tt]++;    }    tot=0;    for(int i=1;i&lt;=m2;i++)    {        if(f[i])        {            int tt=0;            for(int j=4,q=i;j&gt;=1;j--)            {                tt*=qq[j];                while(q%pp[j]==0)                {                    q/=pp[j];                    ++tt;                }            }            D[tt]=f[i];        }    }    for(int i=0;i&lt;NN;i++)    {        C[i]+=D[i];        C[i]-=C[i]&gt;=mod?mod:0;    }    int tttt=0;    for(int i=0;i&lt;NN;i++)    {        if(C[i])        {            D[++tttt]=C[i];        }    }    sort(D+1,D+1+tttt,cmp);    Q.push(node(1,1));    int cnt=0;    node q;    LL ans=0;    while(Q.size())    {        q=Q.top();        Q.pop();        ans+=q.val%mod;        ans-=ans&gt;=mod?mod:0;        ++cnt;        if(cnt==k)        {            break;        }        if(q.x!=q.y)        {            ans+=q.val%mod;            ans-=ans&gt;=mod?mod:0;            ++cnt;            if(cnt==k)            {                break;            }            if(q.x+1&lt;=tttt)            {                Q.push(node(q.x+1,q.y));            }        }        if(q.x==1&amp;&amp;q.y+1&lt;=tttt)        {            Q.push(node(q.x,q.y+1));        }    }    printf(&quot;%I64d\n&quot;,ans);    return ;}int main(){    //freopen(&quot;gold.in&quot;,&quot;r&quot;,stdin);    //freopen(&quot;gold.out&quot;,&quot;w&quot;,stdout);    cin&gt;&gt;n&gt;&gt;k;    if(n&lt;=2000000)    {        work1();    }    else    {        work2();    }    return 0;}</code></pre><p>代码中的A,B,C,D数组是什么鬼？t,tt,ttt,tttt记的是什么？这些嘛，自己看自己想，反正就是乱整就对了.</p><p>至于为什么NTT不会出现结果超出998244353的情况，我只能说，打表发现，A,B,C,D这些东西并不是很大.</p><p><strong>这份代码在bzoj上光荣拿到了倒数第2(用户:problem_set)，想想吧，人家数位dp自然是比这个暴力+NTT要快很多的</strong></p>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> algorithm </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中原创三题</title>
      <link href="/2019/03/22/article0004/"/>
      <url>/2019/03/22/article0004/</url>
      
        <content type="html"><![CDATA[<p>这里贴三道高中阶段原创数学试题(函数题,导数题): 命制时间分别是高一、高二和高三。</p><p>1.高一时脑洞大开命制的题目<br>$$<br>\begin{align}<br>   &amp;已知函数f(x)=x^a\cdot\ln{x}-b,其中\ a&gt;0,b&gt;0.\\<br>   &amp;(1)记f(x)的单调递减区间为A,如果\forall u&gt;0, 函数g(x)=u^x-ux在区间A上单调递减,\\&amp;求a的取值范围;\\<br>   &amp;(2)若e^{2a}\cdot b^{a-1}&lt;1, 证明:\exists k\not=1,使得关于x的方程:f(kx)=k\cdot f(x)有解.<br>   \end{align}<br>$$</p><p>2.高二时命制的题目,实际上并不算是一个导数题 _仿照2016年全国卷II –21题_<br>$$<br>\begin{align}<br>&amp;已知函数f(x)=x^2+\frac{1}{(x+a)^2},x\in[0,+\infty),其中\ a&gt;0.记f(x)的最小值为h(a).\\<br>&amp;(1)求h(a)的值域,并证明:h(1)&gt;\frac{1}{2};\\<br>&amp;(2)证明:h(a)&lt;4\cdot h(2a)\ .<br>\end{align}<br>$$</p><p>3.仿照全国卷的风格，此题成于2018年6月7日晚，正是本人考完高考数学的那天晚上<br>$$<br>\begin{align}<br>&amp;已知函数f(x)=e^x-a(x+b)^2,其中\ a,b\in \bf R \rm, a&gt;0.\\<br>&amp;(1)证明:当关于x的方程f(x)=f(-x)有非零解时,ab&gt;\frac{1}{2};\\<br>&amp;(2)若f(x)有两个不等极值点x_1,x_2,证明:f\left(x+2\left|x_1-x_2\right|\right)&gt;f(x)\ .<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> high school </tag>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20190321物理课堂习题笔记</title>
      <link href="/2019/03/21/article0003/"/>
      <url>/2019/03/21/article0003/</url>
      
        <content type="html"><![CDATA[<p><img src="/image/article000301.png" style="zoom:80%"><br>关于上题，课上给出两种做法。</p><p>方法一：<br>地面参考系下: 设小球水平运动位移为$\vec{s}$, 则力$\vec{F}$作用位移为$(\vec{l}+\vec{s})$.<br>对小球,水平方向加速度:$a_hm=\frac{F}{2\cos{\theta}}\cdot \cos{\theta}$ 所以水平速度:<br>$v_h=\sqrt{2a_h\cdot s}=\sqrt{\frac{Fs}{m}}$<br>由动能定理有:<br>$2\times(\frac{1}{2}mv_v^2+\frac{1}{2}mv_h^2)=F(l+s)$<br>解之即得_s可以消去_:竖直方向速度: $v_v = \sqrt{\frac{Fl}{m}}$ </p><p>方法二:<br>对于小球参考系，由于小球参考系不是惯性系，故应该考虑惯性力做功。<br>但实际上，由于惯性力是水平方向的，与小球的运动方向_小球参考系_垂直，不做功。<br>故而有: $2\times\frac{1}{2}mv^2=F\cdot l$<br>所以:$v=\sqrt{\frac{Fl}{m}}$</p><p>这里有一个小的问题，如果说惯性力与小球运动方向垂直不做功，那F不也是与小球运动方向垂直，为什么要做功&#40;小球参考系&#41;？ 小球受到的惯性力是水平的，故而不做功。但F是对绳做功，绳对小球做功。F的方向与绳运动方向不垂直，绳的拉力方向与小球运动方向也不垂直，且两者大小是相等的_因为轻质绳无质量，无动能_。</p><p>以上两种是课上老师提出的做法。<br>下面重点列出我的做法：</p><p>方法三:</p><p>记两小球间的距离为$2h$.则有竖直方向速度$v=-\frac{dh}{dt}$ .<br>由牛顿第二定律:_主要思想是按角度积分_<br>$$<br>\begin{align}<br>\frac{F}{2\cdot \cos{\theta}}\cdot \sin{\theta}&amp;=m\cdot\frac{dv}{dt}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \  \ \ \  \ \ \  \ \ \ \ \ \ \ \ \ (1)\\<br>\tan{\theta}&amp;=\frac{h}{\sqrt{l^2-h^2}}\\<br>\frac{d\theta}{\cos^2{\theta}}&amp;=\frac{l^2dh}{(l^2-h^2)^\frac{3}{2}}=\frac{-vdt}{l\cos^3{\theta}}\\<br>dt&amp;=-\frac{l\cos{\theta \cdot d\theta}}{v}\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (2)<br>\end{align}<br>$$<br>将(2)代入(1)得:<br>$$<br>\begin{align}<br>m\cdot dv&amp;=-\frac{F\cdot\sin{\theta}}{2\cdot\cos{\theta}}\cdot\frac{l\cos{\theta}\cdot d\theta}{v}=-\frac{Fl\cdot\sin{\theta}}{2v}d\theta\\<br>\int_{0}^{v}2mv\cdot dv&amp;=-Fl\int_{\frac{\pi}{2}}^{0}\sin{\theta}\cdot d\theta\\<br>mv^2&amp;=Fl\cdot \cos{\theta}\big|_{\frac{\pi}{2}}^{0}=Fl\\<br>v&amp;=\sqrt{\frac{Fl}{m}}<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> physics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
            <tag> physics </tag>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空间向量叉积,数量积简单结论的证明</title>
      <link href="/2019/03/20/article0002/"/>
      <url>/2019/03/20/article0002/</url>
      
        <content type="html"><![CDATA[<p>1.$(\vec{a} \times \vec{b})\cdot \vec{c} = \vec{a}\cdot (\vec{b}\times \vec{c})$<br>Proof:<br>$$<br>\begin{align}<br>\vec{a} = (&amp;a_1, a_2, a_3), \vec{b} = (b_1, b_2, b_3), \vec{c} = (c_1, c_2, c_3)\\<br>Left &amp;= \left| \begin{matrix}<br>        \vec{i}&amp;\vec{j}&amp;\vec{k} \\<br>        a_1&amp;a_2&amp;a_3\\<br>        b_1&amp;b_2&amp;b_3<br>        \end{matrix} \right|<br>        \cdot(c_1\vec{i}+c_2\vec{j}+c_3\vec{k}) \\ &amp;= \left| \begin{matrix}<br>        \vec{i}\cdot(c_1\vec{i}+c_2\vec{j}+c_3\vec{k})&amp;\vec{j}\cdot(c_1\vec{i}+c_2\vec{j}+c_3\vec{k})&amp;\vec{k}\cdot(c_1\vec{i}+c_2\vec{j}+c_3\vec{k}) \\<br>        a_1&amp;a_2&amp;a_3\\<br>        b_1&amp;b_2&amp;b_3<br>        \end{matrix} \right| \\ &amp;= \left| \begin{matrix}<br>        c_1&amp;c_2&amp;c_3\\<br>        a_1&amp;a_2&amp;a_3\\<br>        b_1&amp;b_2&amp;b_3\\<br>        \end{matrix} \right| = \left| \begin{matrix}<br>        a_1&amp;a_2&amp;a_3\\<br>        b_1&amp;b_2&amp;b_3\\<br>        c_1&amp;c_2&amp;c_3\\<br>        \end{matrix} \right| = Right<br>\end{align}<br>$$<br>2.$\vec{a}\times(\vec{b}\times \vec{c})=(\vec{a}\cdot\vec{c})\vec{b} - (\vec{a}\cdot\vec{b})\vec{c}$<br>Proof:<br>$$<br>\begin{align}<br>&amp;\vec{a}\times(\vec{b}\times\vec{c})=\vec{a}\times<br>\left|\begin{matrix}\vec{i}&amp;\vec{j}&amp;\vec{k}\\b_1&amp;b_2&amp;b_3\\c_1&amp;c_2&amp;c_3 \end{matrix} \right|\\ &amp;= \left|\begin{matrix}\vec{i}&amp;\vec{j}&amp;\vec{k}\\ a_1&amp;a_2&amp;a_3 \\ \left|\begin{matrix}b_2&amp;b_3\\c_2&amp;c_3\end{matrix} \right|&amp;-\left|\begin{matrix}b_1&amp;b_3\\c_1&amp;c_3\end{matrix}\right|&amp;\left|\begin{matrix}b_1&amp;b_2\\c_1&amp;c_2\end{matrix}\right| \end{matrix} \right|\\&amp;=\left(a_2\left|\begin{matrix}b_1&amp;b_2\\c_1&amp;c_2\end{matrix}\right|+a_3\left|\begin{matrix}b_1&amp;b_3\\c_1&amp;c_3\end{matrix}\right|\right)\vec{i}-\left(a_1\left|\begin{matrix}b_1&amp;b_2\\c_1&amp;c_2\end{matrix}\right|-a_3\left|\begin{matrix}b_2&amp;b_3\\c_2&amp;c_3\end{matrix}\right|\right)\vec{j}+\left(-a_1\left|\begin{matrix}b_1&amp;b_3\\c_1&amp;c_3\end{matrix}\right|-a_2\left|\begin{matrix}b_2&amp;b_3\\c_2&amp;c_3\end{matrix}\right|\right)\vec{k}\\<br>&amp;=\left(a_1\left|\begin{matrix}b_1&amp;b_1\\c_1&amp;c_1\end{matrix}\right|+a_2\left|\begin{matrix}b_1&amp;b_2\\c_1&amp;c_2\end{matrix}\right|+a_3\left|\begin{matrix}b_1&amp;b_3\\c_1&amp;c_3\end{matrix}\right|\right)\vec{i}+\left(a_1\left|\begin{matrix}b_2&amp;b_1\\c_2&amp;c_1\end{matrix}\right|+a_2\left|\begin{matrix}b_2&amp;b_2\\c_2&amp;c_2\end{matrix}\right|+a_3\left|\begin{matrix}b_2&amp;b_3\\c_2&amp;c_3\end{matrix}\right|\right)\vec{j}\\&amp; \ \ \ \ \ \ +\left(a_1\left|\begin{matrix}b_3&amp;b_1\\c_3&amp;c_1\end{matrix}\right|+a_2\left|\begin{matrix}b_3&amp;b_2\\c_3&amp;c_2\end{matrix}\right|+a_3\left|\begin{matrix}b_3&amp;b_3\\c_3&amp;c_3\end{matrix}\right|\right)\vec{k}\\&amp;=\left|\begin{matrix}b_1&amp;\vec{a}\cdot\vec{b}\\c_1&amp;\vec{a}\cdot\vec{c}\end{matrix}\right|\vec{i}+\left|\begin{matrix}b_2&amp;\vec{a}\cdot\vec{b}\\c_2&amp;\vec{a}\cdot\vec{c}\end{matrix}\right|\vec{j}+\left|\begin{matrix}b_3&amp;\vec{a}\cdot\vec{b}\\c_3&amp;\vec{a}\cdot\vec{c}\end{matrix}\right|\vec{k}=(\vec{a}\cdot\vec{c})\vec{b}-(\vec{a}\cdot\vec{b})\vec{c}<br>\end{align}<br>$$<br>3.$(\vec{a}\times\vec{b})\cdot(\vec{c}\times\vec{d})=\left|\begin{matrix}\vec{a}\cdot\vec{c}&amp;\vec{b}\cdot\vec{c}\\ \vec{a}\cdot\vec{d}&amp;\vec{b}\cdot\vec{d}\end{matrix}\right|$<br>Proof:<br>Notice: $(\vec{a}\times\vec{b})\cdot\vec{c}=\vec{a}\cdot(\vec{b}\times\vec{c})$ and $\vec{a}\times(\vec{b}\times \vec{c})=(\vec{a}\cdot\vec{c})\vec{b} - (\vec{a}\cdot\vec{b})\vec{c}$ , we have:<br>$$<br>\begin{align}<br>Left &amp;= \vec{a}\cdot\left(\vec{b}\times(\vec{c}\times{d})\right) =\vec{a}\cdot\left((\vec{b}\cdot\vec{d})\vec{c}-(\vec{b}\cdot\vec{c})\vec{d}\right)\\&amp;=(\vec{a}\cdot\vec{c})(\vec{b}\cdot\vec{d})-(\vec{a}\cdot\vec{d})(\vec{b}\cdot\vec{c})=Right<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello world!</title>
      <link href="/2019/03/20/article0001/"/>
      <url>/2019/03/20/article0001/</url>
      
        <content type="html"><![CDATA[<p>第一篇文章就叫Hello world吧。<br>定期更新关于数学，物理，计算机等方面的博客。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
